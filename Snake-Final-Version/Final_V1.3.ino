#include <MaxMatrix.h>


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// SETEAMOS TODO //////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//Seteamos los pins a usar de la LED 8x8
int data = 11;
int load = 13;
int clk = 10;


int maxInUse = 1;    //Numero de displays a usar
MaxMatrix m(data, load, clk, maxInUse); //Definimos matriz


//Gris == Arriba . Pin 3
int up = 3;
//Violeta == dewrecha .  Pin 2
int right = 2;
//Celeste == abajo . Pin 4
int down = 4;
//Naranja == izq . Pin 5
int left = 5;
//Rojo == vcc 




//TamaÃ±o de la matriz OJO NOS FALTA PONER Q SEA DE 16 x 16
#define SIZE 8

//Definimos valores para los movimientos
#define RIGHT -1
#define DOWN 2
#define LEFT 1
#define UP -2

//Codigo ascii de las letras del teclado: la snake deberia moverse apretando w a s d
#define w_KEY 119
#define s_KEY 115
#define a_KEY 97
#define d_KEY 100

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// CODIGO DE LA SNAKE /////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Inicializamos las variables a usar
int length = 0;
int direction = UP;


//Creamos la struct. OJO, NO ESTA en coordenadas matriciales.
typedef struct {
  int x;
  int y;
}snake_point;
 

//Armamos vector de 256 Structs. 256 son todos los leds posibles de una matriz de 16x16 (4 leds de 8x8)
snake_point snake[SIZE*SIZE];
// inicializo en 0???????????? HACE FALTA>????????


//Armo puntero a la cabeza, para facilitar lectura del codigo
snake_point * head = &snake[0];


snake_point erase_body;

//Inicializamos el juego.
void init_game() {

  //LONGITUD INICIAL DE LA SERPIENTE
    length = 2;

    //RECORREMOS EL VECTOR DE LA SERPIENTE Y SETEAMOS LAS COORDENADAS INICIALES DE LA CABEZA Y EL SIG.
    for(int i = 0 ; i < length; i++ ) {
      snake[i].x = SIZE/2;
      snake[i].y = SIZE/2 + i;
    }

    //PRENDEMOS LA PANTALLA
    render_snake();
}



//Avanzamos la snake considerando si perdiste o no.

void advance() {

  erase_body.x = snake[length-1].x;
  erase_body.y = snake[length-1].y;
  
  //VOY MOVIENDO LA CABEZA PARA LOS SIGUIENTES
  for (int i = length-1 ; i > 0 ; i--) {
    snake[i].x = snake[i-1].x;
    snake[i].y = snake[i-1].y;
  }

  switch(direction) {
    case RIGHT: (*head).x++;
                break;
    case DOWN: (*head).y++; //OJO DONDE SE ENCUENTRA EL 0,0
                break;
    case LEFT: (*head).x--;
                break;
    case UP: (*head).y--;
                break;
  }

//VEMOS SI SE VA DE LA MATRIZ
  if ( (*head).x > SIZE-1 || (*head).x < 0 || (*head).y > SIZE-1 || (*head).y < 0 ) {
    //snake crossed the bor
    game_over();
    return;
  }

//CUANDO SE CHOCA CON LA SERPIENTE
  for( int i = 1 ; i < length ; i++ ) {
    if( snake[i].x == (*head).x && snake[i].y == (*head).y ){
      // the snake ran into itself
      game_over();
      return;
      }
  }

  render_snake();
}

void inc_length() {
  snake[length].x = snake[length-1].x;
  snake[length].y = snake[length-1].y;
  advance();
  
  length++;
}


//verifica que valga el movimiento
void change_dir(int new_dir) {
  if ( ! (new_dir + direction == 0) ) {
    direction = new_dir;
  }
}


void game_over(){
  for(int i = 0 ; i < SIZE ; i++ ){
    for(int j=0 ; j<SIZE ; j++){
      m.setDot(i,j,1);
    }
  }
  delay(1000);
  m.clear();

  
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////









/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// CODIGO DEL SETUP ///////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void setup(){
    m.init();                      // Iniciar el conjunto
    m.setIntensity(0);             // Brillo de los displays. Entre 0 y 15 
    
  // Comento todo lo que tiene que ver con los pines del switch.
  /*
    //Seteo el modo de los pins para que sean todos INPUT
    pinMode(up, INPUT);            
    pinMode(down, INPUT);
    pinMode(right, INPUT);
    pinMode(left, INPUT);
  */
  

//    m.setDot(0,0,1);               // Seteo el punto inicial. (col,row,value)
//    m.setDot(3,4,1);
//    m.setDot(3,5,1);
// .  Serial.begin(115200);          // Sets the data rate in bits per second (baud) for serial data transmission
    
    init_game();
  
  // abro el serial este para leer el teclado
   Serial.begin(9600);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////// CODIGO PARA PRENDER LOS LEDS /////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//PRENDE PUNTITOS EN BASE A LOS DEL ARREGLO SNAKE

void render_snake(){
  m.setDot((*head).x,(*head).y,1);
  m.setDot(erase_body.x,erase_body.y,0);
  
//  m.clear();
//   for(int i = 0 ; i < length ; i++ ){
//      m.setDot(snake[i].x,snake[i].y,1);
//  }
  
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// CODIGO DEL LOOP ////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Inicializamos variables que van a recibir HIGH o LOW para detectar moves
int val1 = 0;
int val2 = 0;
int val3 = 0;
int val4 = 0;
int counter=0;
int total_time = 0;
int t=1500;
//ME FIJO SI CAMBIO ALGUN BOTON, EN FUNCION A ESO ACTUALIZO LA SERPIENTE, DPS DE ESO IMPRIMO LA SERPIENTE ACTUALIZADA
//TODO ESTO LO HCES CON UN CIERTO DELAY, DPS ESE DELAY LO VAS DISMINUYENDO CADA CIERTO TIEMPO


void loop(){
  
  // comento todo lo del joystick
  /*
  val1 = digitalRead(up);
  val2 = digitalRead(down);
  val3 = digitalRead(left);
  val4 = digitalRead(right);

//Esto significa que apretaron el UP
  if(val1 == HIGH){
    change_dir(UP);
  }
  //Esto significa que apretaron el DOWN
  else if(val2 == HIGH){
    change_dir(DOWN);
  }
  //Esto significa que apretaron el LEFT
  else if(val3 == HIGH){
    change_dir(LEFT);
  }
  //Esto significa que apretaron el RIGHT
  else if(val4 == HIGH){
    change_dir(RIGHT);
  }
    
  */

  while (Serial.available() > 0) {    // is a character available?
    char byte_read = Serial.read();       // get the character
    switch( byte_read ) {
     case w_KEY: change_dir( UP );
                  break;
     case s_KEY: change_dir( DOWN );
                  break;
     case a_KEY: change_dir( LEFT );
                  break;
     case d_KEY: change_dir( RIGHT );
                  break;
    }
  }

  counter += t;
  total_time += t;
  
  delay(t);

  advance();

  if(counter >= 15000){
    inc_length();
    counter = 0;
    
    t = t/2;
   
  }
 
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////// CODIGO DE LA MATRIZ ////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//Preparamos la matriz con las letras para poder representar alfinal del codigo el time 
char matrix[129][8] = {
 
 { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0020 (space)
 { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00}, // U+0030 (0)
 { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00}, // U+0031 (1)
 { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00}, // U+0032 (2)
 { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00}, // U+0033 (3)
 { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00}, // U+0034 (4)
 { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00}, // U+0035 (5)
 { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00}, // U+0036 (6)
 { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00}, // U+0037 (7)
 { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00}, // U+0038 (8)
 { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00}, // U+0039 (9)
 { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // U+003A (:)
 
 { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00}, // U+0041 (A)
 { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00}, // U+0042 (B)
 { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00}, // U+0043 (C)
 { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00}, // U+0044 (D)
 { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00}, // U+0045 (E)
 { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00}, // U+0046 (F)
 { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00}, // U+0047 (G)
 { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00}, // U+0048 (H)
 { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // U+0049 (I)
 { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00}, // U+004A (J)
 { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00}, // U+004B (K)
 { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00}, // U+004C (L)
 { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00}, // U+004D (M)
 { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00}, // U+004E (N)
 { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00}, // U+004F (O)
 { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00}, // U+0050 (P)
 { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00}, // U+0051 (Q)
 { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00}, // U+0052 (R)
 { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00}, // U+0053 (S)
 { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // U+0054 (T)
 { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00}, // U+0055 (U)
 { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // U+0056 (V)
 { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // U+0057 (W)
 { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00}, // U+0058 (X)
 { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00}, // U+0059 (Y)
 { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00}, // U+005A (Z)
 { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00}, // U+005B ([)
 { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00}, // U+005C (\)
 { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00}, // U+005D (])
 { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00}, // U+005E (^)
 { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // U+005F (_)
 { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0060 (`)
 { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00}, // U+0061 (a)
 { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00}, // U+0062 (b)
 { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00}, // U+0063 (c)
 { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00}, // U+0064 (d)
 { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00}, // U+0065 (e)
 { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00}, // U+0066 (f)
 { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F}, // U+0067 (g)
 { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00}, // U+0068 (h)
 { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // U+0069 (i)
 { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E}, // U+006A (j)
 { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00}, // U+006B (k)
 { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // U+006C (l)
 { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00}, // U+006D (m)
 { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00}, // U+006E (n)
 { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00}, // U+006F (o)
 { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F}, // U+0070 (p)
 { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78}, // U+0071 (q)
 { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00}, // U+0072 (r)
 { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00}, // U+0073 (s)
 { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00}, // U+0074 (t)
 { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00}, // U+0075 (u)
 { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // U+0076 (v)
 { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00}, // U+0077 (w)
 { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00}, // U+0078 (x)
 { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F}, // U+0079 (y)
 { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00}, // U+007A (z)
 { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00}, // U+007B ({)
 { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // U+007C (|)
 { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00}, // U+007D (})
 { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+007E (~)
 { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+007F
 { 0x66, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00} // U+0080
};




//Funcion para escribir un char en el led de 8x8
void writeChar(char c){
  for(int i = 0 ; i < 8 ; i++ ){
    m.setColumn(7-i,matrix[c][i]);
  }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
